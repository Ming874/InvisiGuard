# 問題分析與優化建議

本文件旨在分析現有浮水印算法的弱點，並提供一個從「緊急修復」到「根本性升級」的完整優化路徑，以期大幅增強其穩健性、對抗壓縮與各種攻擊的能力。

## 第一部分：現有算法的「三大脆弱點」

目前的 DCT 浮水印代碼之所以在面對輕微的圖像壓縮（如 JPEG 存檔、社群媒體傳輸）或裁切時容易失效，主要源於以下三個設計上的脆弱點：

1.  **頻域選擇不當 (中高頻嵌入)**：目前選用的 `(4,3)`、`(3,4)` DCT 係數位置屬於中高頻範圍。有損壓縮算法（如 JPEG）的核心思想就是優先捨棄人眼不敏感的中高頻細節。因此，浮水印資訊在壓縮過程中被當作「雜訊」抹除。

2.  **無效的錯誤校正 (All-or-Nothing)**：目前的設計是「一個區塊藏一個位元」，且依賴 `INV` 這個固定的 Header 來定位。這意味著，只要訊息中的任何一個位元因為雜訊、反光或壓縮而讀取錯誤，解碼就會全盤失敗。這種「全有或全無」的機制在現實場景中極其脆弱。

3.  **平坦區訊號過弱 (無嵌入)**：在天空、白牆等顏色單一的區域，用於調節嵌入強度的 Laplacian 遮罩值趨近於零。這導致嵌入強度 `gap` 也趨近於零，浮水印實際上「沒有被寫入」，在這些區域留下了巨大的破綻。

---

## 第二部分：第一階段優化 (短期修復)

在不重構核心算法的前提下，以下三項修改可以立即、顯著地提升浮水印的存活率。

### 優化 1：更換 DCT 嵌入位置 (提升抗壓縮性)

- **目標**：將浮水印移至能量更集中、在壓縮中更不易遺失的「中低頻」區域。
- **作法**：在 `embedding.py` 和 `extraction.py` 中，將 DCT 係數索引從高頻位置 `(4, 3)` 和 `(3, 4)` 調整到更穩健的中低頻位置 `(3, 1)` 和 `(1, 3)`。

### 優化 2：引入「重複編碼」容錯機制 (提升抗噪性)

- **目標**：從「零容錯」升級為具備基本糾錯能力的系統。即使部分區塊損壞，仍能透過「多數決」還原原始訊息。
- **作法**：
    1.  **嵌入端 (`embedding.py`)**：將每個原始 bit（0 或 1）重複 5 次再寫入。`[1, 0, 1]` 會變成 `[1,1,1,1,1, 0,0,0,0,0, 1,1,1,1,1]`。
    2.  **提取端 (`extraction.py`)**：讀取時，每 5 個 bit 為一組，採用「五戰三勝」的投票策略。例如，讀到 `[1,0,1,1,0]`，因為 1 的數量 (3個) 超過半數，就判定原始 bit 為 `1`。

### 優化 3：設定「最小嵌入強度」 (修補平坦區)

- **目標**：確保即使在顏色平坦的區域，浮水印依然能以一個保底的強度被嵌入。
- **作法**：在 `embedding.py` 計算 `gap` 時，加入一個固定的 `base_strength`。這樣，即使 `local_alpha` 為零，`gap` 也能維持在一個最小有效值，確保浮水印成功寫入。

---

## 第三部分：第二階段優化 (核心算法升級)

### 升級 1：算法核心 - 從 DCT 區塊到 DWT 全局分析

- **當前問題**：基於 $8 \times 8$ DCT 區塊的作法，其本質弱點在於對抗幾何攻擊（如裁切、旋轉、縮放）。一旦圖像被裁切，區塊的對齊就會錯位，導致解碼完全失敗。

- **升級方向：離散小波轉換 (DWT - Discrete Wavelet Transform)**
    DWT 不再將圖片切成小碎塊，而是將整張圖一次性分解成不同層次的頻率子帶 (Sub-bands)，提供了一個更宏觀、更具全局性的視角。

- **核心概念**：
    1.  **全局分解**：使用 `pywt.dwt2` 將圖像一次性分解為四個部分：
        - `LL` (低頻子帶): 包含圖像的主要能量和輪廓，最穩定，對應原圖的縮小版。
        - `LH` (低頻-高頻): 垂直方向的細節（水平邊緣）。
        - `HL` (高頻-低頻): 水平方向的細節（垂直邊緣）。
        - `HH` (高頻-高頻): 對角線方向的細節。
    2.  **穩健嵌入**：浮水印資訊可以被嵌入到 `LL` 子帶中。由於 `LL` 子帶代表了圖像最核心的能量分佈，對它進行修改能抵抗非常劇烈的壓縮和一定程度的裁切。嵌入在 `LL` 中抗破壞性最強，但可能犧牲一些畫質；嵌入在 `LH` 或 `HL` 中畫質較好，但相對脆弱。
    3.  **推薦作法**：將浮水印藏在 `LL` 子帶，並可結合奇異值分解 (SVD) 來進一步增強穩健性。

- **實作指引**：
    - **工具安裝**: `pip install PyWavelets`
    - **程式碼範例**:
      ```python
      import pywt
      import numpy as np
      
      # 假設 image_gray 是灰階圖像的 NumPy 陣列
      # 1. 使用 'haar' 小波對圖像進行二維 DWT 分解
      coeffs = pywt.dwt2(image_gray, 'haar')
      LL, (LH, HL, HH) = coeffs
      
      # 2. 在 LL 子帶中嵌入浮水印 (這裡是示意，需結合 QIM 等方法)
      # 例如: LL_watermarked = embed_in_LL(LL, watermark_bits)
      
      # 3. 使用修改後的係數重構圖像
      # new_coeffs = LL_watermarked, (LH, HL, HH)
      # watermarked_image = pywt.idwt2(new_coeffs, 'haar')
      ```

### 升級 2：嵌入方式 - 從「比較大小」到 QIM 量化調變

- **當前問題**：`if A > B then bit is 1` 這種簡單的比較法極其脆弱。只要微小的噪點就可能讓 `A` 和 `B` 的大小關係翻轉，導致 bit 錯誤。

- **升級方向：量化索引調變 (QIM - Quantization Index Modulation)**
    QIM 是一種更為強健的資訊隱藏技術。它不依賴兩個數值的相對大小，而是將一個數值「強制」歸到預設的「量化步長」的奇數倍或偶數倍上，以此來代表 0 或 1。

- **核心概念**：
    - 假設我們的量化步長 (Quantization Step) `delta` 是一個常數（例如 10）。
    - **嵌入 `0`**: 將目標數值 `v` 強制捨入到最近的 `delta` 的 **偶數倍**。
    - **嵌入 `1`**: 將目標數值 `v` 強制捨入到最近的 `delta` 的 **奇數倍**。
    - **解碼範例**: 假設 `delta = 10`。讀取到一個數值 `v' = 21`。我們判斷 `21` 離哪個目標點最近：
        - 最近的偶數倍是 `20` (`|21-20| = 1`)。
        - 最近的奇數倍是 `10` 和 `30`，較近的是 `30` (`|21-30| = 9`) (註: 應為 `15`, `25`, 此處為簡化說明)。更精確地說，是判斷其落在哪個區間。
        - **正確解碼邏輯**: 讀到 `v'`，計算 `round(v'/delta)`。如果結果是偶數，則 bit 為 0；如果是奇數，則 bit 為 1。`round(21/10) = 2` (偶數)，故解碼為 0。
    - **優勢**: 只要雜訊的強度不足以將數值 `v'` 推過量化區間的中點 (例如 `15` 或 `25`)，解碼就是 100% 正確的，穩定性遠超簡單比較。

### 升級 3：糾錯碼 - 從「重複投票」到前向錯誤更正 (FEC)

- **當前問題**：重複 5 次的「多數決」是一種極其基礎的糾錯法，效率低且糾錯能力有限。它依賴「猜測」，而不是數學上的「修復」。

- **升級方向：前向錯誤更正 (FEC - Forward Error Correction)**
    FEC 是一種數學方法，它在原始數據中加入冗餘資訊（校驗碼），使得接收端在數據遭到一定程度的損壞時，能夠不需重傳，直接「反解」出原始的正確數據。其中，**BCH 碼** 和 **里德-所羅門碼 (Reed-Solomon codes)** 是兩種最經典且廣泛應用的 FEC 技術，常見於 QR Code、衛星通訊和光碟儲存中。

- **核心概念**：
    - **數學修復**: FEC 透過在原始數據後面附加一小段「校驗位元/字節」(Parity data) 來實現糾錯。當讀取端接收到數據時，它能利用代數結構反解出錯誤發生的位置並直接「修復」錯誤。
    - **能力保證**: 一個設計好的 FEC 碼可以**保證**在錯誤數量不超過其設計上限 `t` 的情況下，**完美還原** 100% 的原始數據。這不是猜測，而是確定性的數學修復。
    - **對比**: 「重複編碼」是把 `1 bit` 變成 `5 bits` (5倍冗餘) 來糾正約 2 bits 的錯誤；FEC 碼可能只需要 `1.5` 倍的冗餘就能達到同樣甚至更強的糾錯效果，效率更高。

- **實作指引**：
    - **工具選擇**:
        - `bchlib`: 一個 C++ 編寫的 BCH 庫的 Python 封裝，性能高，但在 Windows 上可能需要安裝 Microsoft C++ Build Tools 等編譯環境。
        - `reedsolo`: 一個純 Python 實現的里德-所羅門碼庫，安裝方便，無需編譯，非常適合快速開發和跨平台部署。**（本專案已採用此方案）**

    - **程式碼範例 (`reedsolo`)**:
      ```python
      from reedsolo import RSCodec, ReedSolomonError
      
      # 1. 初始化 Reed-Solomon 編碼器
      #    nsym = 10 表示使用 10 個 ECC byte，可以修正 10/2 = 5 個 byte 的錯誤
      rsc = RSCodec(nsym=10)
      
      # 2. 嵌入端：對數據進行編碼
      #    為確保數據塊長度固定，先進行填充 (padding)
      max_data_len = 255 - 10 # 255 是 GF(2^8) 的最大長度
      data = bytearray(b'Your secret message')
      padded_data = data + b'\0' * (max_data_len - len(data))

      packet = rsc.encode(padded_data)  # 編碼後 packet 長度為 255 bytes
      
      # ... 將 packet 轉換成 bits 並用 DWT+QIM 嵌入 ...
      
      # 3. 提取端：解碼並修復錯誤
      # ... 從圖像中提取出 bits，轉換回 255 bytes 的 packet ...
      
      try:
          # decode 會自動分離數據和 ECC，並進行修復
          decoded_data, _, _ = rsc.decode(packet)
          
          # 去除填充
          # message = decoded_data.rstrip(b'\0')
          # (註：更穩健的作法是在數據頭部包含長度訊息，本專案已採用此方法)

          print(f"Correction successful.")
          print(f"Decoded message: {decoded_data.decode(errors='ignore')}")
      except ReedSolomonError:
          print("Decoding failed, too many errors.")
      ```

## 總結與最終路線圖

1.  **第一階段**：完成 **第二部分 (緊急修復)** 的三項優化，讓 DCT 系統達到「可用」標準。
2.  **第二階段**：執行 **第三部分 (根本性升級)**，採用以 **DWT + QIM + FEC (里德-所羅門碼)** 為核心技術棧的新版本，達到業界認可的穩健浮水印系統水平。**（目前已完成此升級）**